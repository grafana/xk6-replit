{
  "crypto": {
    "kind": "variable",
    "name": "crypto",
    "documentation": "",
    "signature": "crypto",
    "type": "Crypto",
    "members": {
      "subtle": {
        "kind": "property",
        "name": "subtle",
        "signature": "readonly subtle: SubtleCrypto;",
        "documentation": "Returns a SubtleCrypto object providing access to common cryptographic primitives, like hashing, signing, encryption, or decryption.",
        "type": "SubtleCrypto"
      },
      "getRandomValues": {
        "kind": "method",
        "name": "getRandomValues",
        "signature": "getRandomValues(typedArray: TypedArray)",
        "documentation": "Fills the passed TypedArray with cryptographically sound random values.",
        "params": [
          {
            "name": "typedArray",
            "type": "TypedArray",
            "documentation": "- The TypedArray to fill with random values."
          }
        ],
        "returns": {
          "type": "TypedArray",
          "documentation": "typedArray argument."
        }
      },
      "randomUUID": {
        "kind": "method",
        "name": "randomUUID",
        "signature": "randomUUID()",
        "documentation": "Returns a 36 character long string containing a cryptographically random UUID v4.",
        "params": [],
        "returns": {
          "type": "string",
          "documentation": "36 character long string containing a cryptographically random UUID v4."
        }
      },
      "decrypt": {
        "kind": "method",
        "name": "decrypt",
        "signature": "decrypt(algorithm: AesCtrParams | AesCbcParams | AesGcmParams | RsaOaepParams, key: CryptoKey, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `decrypt()` method decrypts some encrypted data.",
        "params": [
          {
            "name": "algorithm",
            "type": "AesCtrParams | AesCbcParams | AesGcmParams | RsaOaepParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to use for decryption."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to decrypt (also known as \"ciphertext\")."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": "promise that resolves with the decrypted data (also known as \"plaintext\")."
        }
      },
      "digest": {
        "kind": "method",
        "name": "digest",
        "signature": "digest(algorithm: HashAlgorithmIdentifier | Algorithm<HashAlgorithmIdentifier>, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `digest()` method computes a cryptographic digest of the given data using the given algorithm. A digest is a fixed-length hash of the original data. It is often used to verify the integrity of the original data, or to create a \"fingerprint\" or \"summary\" of the original data that can be used to identify it. Cryptographic digests should exhibit collision-resistance, meaning that it's hard to come up with two different inputs that have the same digest value.",
        "params": [
          {
            "name": "algorithm",
            "type": "HashAlgorithmIdentifier | Algorithm<HashAlgorithmIdentifier>",
            "documentation": "names the algorithm to use."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to be digested"
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": "promise that resolves with the digest value."
        }
      },
      "encrypt": {
        "kind": "method",
        "name": "encrypt",
        "signature": "encrypt(algorithm: AesCtrParams | AesCbcParams | AesGcmParams | RsaOaepParams, key: CryptoKey, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `encrypt()` method encrypts data.",
        "params": [
          {
            "name": "algorithm",
            "type": "AesCtrParams | AesCbcParams | AesGcmParams | RsaOaepParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to use for encryption."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to encrypt (also known as \"plaintext\")."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": "promise that resolves with the encrypted data (also known as \"ciphertext\")."
        }
      },
      "exportKey": {
        "kind": "method",
        "name": "exportKey",
        "signature": "exportKey(format: \"raw\" | \"jwk\" | \"spki\" | \"pkcs8\", key: CryptoKey)",
        "documentation": "The `exportKey()` method exports a key: that is, it takes as input a `CryptoKey` object and gives you the key in an external, portable format. To export a key, the key must have `CryptoKey.extractable` set to `true`.",
        "params": [
          {
            "name": "format",
            "type": "\"raw\" | \"jwk\" | \"spki\" | \"pkcs8\"",
            "documentation": "the format in which to export the key."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to export."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer | JWK>",
          "documentation": "promise that resolves with the exported key."
        }
      },
      "generateKey": [
        {
          "kind": "method",
          "name": "generateKey",
          "signature": "generateKey(algorithm: AesKeyGenParams | HmacKeyGenParams, extractable: boolean, keyUsages: (\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\")[])",
          "documentation": "Use the `generateKey()` method to generate a new key.",
          "params": [
            {
              "name": "algorithm",
              "type": "AesKeyGenParams | HmacKeyGenParams",
              "documentation": "defines the type of key to generate and providing extra algorithm-specific parameters."
            },
            {
              "name": "extractable",
              "type": "boolean",
              "documentation": "indicates whether it will be possible to export the key using `SubtleCrypto.exportKey()` or `SubtleCrypto.wrapKey`."
            },
            {
              "name": "keyUsages",
              "type": "(\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\")[]",
              "documentation": "indicates what can be done with the newly generated key."
            }
          ],
          "returns": {
            "type": "Promise<CryptoKey>",
            "documentation": "promise that resolves with the newly generated `CryptoKey`."
          }
        },
        {
          "kind": "method",
          "name": "generateKey",
          "signature": "generateKey(algorithm: EcKeyGenParams | RSAHashedKeyGenParams, extractable: boolean, keyUsages: (\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\")[])",
          "documentation": "Use the `generateKey()` method to generate a new key pair for asymmetric algorithms.",
          "params": [
            {
              "name": "algorithm",
              "type": "EcKeyGenParams | RSAHashedKeyGenParams",
              "documentation": "defines the type of key to generate and providing extra algorithm-specific parameters."
            },
            {
              "name": "extractable",
              "type": "boolean",
              "documentation": "indicates whether it will be possible to export the key using `SubtleCrypto.exportKey()` or `SubtleCrypto.wrapKey`."
            },
            {
              "name": "keyUsages",
              "type": "(\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\")[]",
              "documentation": "indicates what can be done with the newly generated key."
            }
          ],
          "returns": {
            "type": "Promise<CryptoKeyPair>",
            "documentation": "promise that resolves with the newly generated `CryptoKeyPair`."
          }
        }
      ],
      "importKey": {
        "kind": "method",
        "name": "importKey",
        "signature": "importKey(format: \"raw\" | \"jwk\" | \"spki\" | \"pkcs8\", keyData: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike> | JWK, algorithm: \"AES-CBC\" | \"AES-CTR\" | \"AES-GCM\" | Algorithm<\"AES-CBC\" | \"AES-CTR\" | \"AES-GCM\"> | HmacImportParams | EcKeyImportParams | RsaHashedImportParams, extractable: boolean, keyUsages: (\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\")[])",
        "documentation": "The `importKey()` method imports a key into a `CryptoKey` object. It takes as input a key in an external, portable format and gives you a `CryptoKey` object that can be used in the Web Crypto API.",
        "params": [
          {
            "name": "format",
            "type": "\"raw\" | \"jwk\" | \"spki\" | \"pkcs8\"",
            "documentation": "the format of the key to import."
          },
          {
            "name": "keyData",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike> | JWK",
            "documentation": "the key data to import."
          },
          {
            "name": "algorithm",
            "type": "\"AES-CBC\" | \"AES-CTR\" | \"AES-GCM\" | Algorithm<\"AES-CBC\" | \"AES-CTR\" | \"AES-GCM\"> | HmacImportParams | EcKeyImportParams | RsaHashedImportParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "extractable",
            "type": "boolean",
            "documentation": "indicates whether it will be possible to export the key using `SubtleCrypto.exportKey()` or `SubtleCrypto.wrapKey`."
          },
          {
            "name": "keyUsages",
            "type": "(\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\")[]",
            "documentation": "indicates what can be done with the newly generated key."
          }
        ],
        "returns": {
          "type": "Promise<CryptoKey>",
          "documentation": "promise that resolves with the imported `CryptoKey`."
        }
      },
      "sign": {
        "kind": "method",
        "name": "sign",
        "signature": "sign(algorithm: \"HMAC\" | Algorithm<\"HMAC\"> | EcdsaParams | RsaPssParams, key: CryptoKey, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `sign()` method generates a digital signature. It takes as its argument a key to sign with, some algorithm-identifier specific parameters, and the data to sign.",
        "params": [
          {
            "name": "algorithm",
            "type": "\"HMAC\" | Algorithm<\"HMAC\"> | EcdsaParams | RsaPssParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to use for signing. If `algorithm` identifies a public-key cryptosystem, this is the private key."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to sign."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": "promise that resolves with the signature."
        }
      },
      "verify": {
        "kind": "method",
        "name": "verify",
        "signature": "verify(algorithm: \"HMAC\" | Algorithm<\"HMAC\"> | EcdsaParams | RsaPssParams, key: CryptoKey, signature: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `verify()` method verifies a digital signature.",
        "params": [
          {
            "name": "algorithm",
            "type": "\"HMAC\" | Algorithm<\"HMAC\"> | EcdsaParams | RsaPssParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to use for verifying. It is the secret key for a symmetric algorithm and the public key for a public-key system."
          },
          {
            "name": "signature",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the signature to verify."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to verify."
          }
        ],
        "returns": {
          "type": "Promise<boolean>",
          "documentation": "promise that resolves with a boolean indicating whether the signature is valid."
        }
      },
      "deriveBits": {
        "kind": "method",
        "name": "deriveBits",
        "signature": "deriveBits(algorithm: EcdhKeyDeriveParams, baseKey: CryptoKey, length: number)",
        "documentation": "The `deriveBits()` method derives an array of bits from a base key.",
        "params": [
          {
            "name": "algorithm",
            "type": "EcdhKeyDeriveParams",
            "documentation": "defines the derivation algorithm to use."
          },
          {
            "name": "baseKey",
            "type": "CryptoKey",
            "documentation": "A `CryptoKey` representing the input to the derivation algorithm. Currently, only an ECDH private key is possible."
          },
          {
            "name": "length",
            "type": "number",
            "documentation": "A number representing the number of bits to derive. Currently, the number should be a multiple of 8."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": ""
        }
      }
    }
  },
  "Crypto": {
    "kind": "interface",
    "name": "Crypto",
    "documentation": "",
    "members": {
      "subtle": {
        "kind": "property",
        "name": "subtle",
        "signature": "readonly subtle: SubtleCrypto;",
        "documentation": "Returns a SubtleCrypto object providing access to common cryptographic primitives, like hashing, signing, encryption, or decryption.",
        "type": "SubtleCrypto"
      },
      "getRandomValues": {
        "kind": "method",
        "name": "getRandomValues",
        "signature": "getRandomValues(typedArray: TypedArray)",
        "documentation": "Fills the passed TypedArray with cryptographically sound random values.",
        "params": [
          {
            "name": "typedArray",
            "type": "TypedArray",
            "documentation": "- The TypedArray to fill with random values."
          }
        ],
        "returns": {
          "type": "TypedArray",
          "documentation": "typedArray argument."
        }
      },
      "randomUUID": {
        "kind": "method",
        "name": "randomUUID",
        "signature": "randomUUID()",
        "documentation": "Returns a 36 character long string containing a cryptographically random UUID v4.",
        "params": [],
        "returns": {
          "type": "string",
          "documentation": "36 character long string containing a cryptographically random UUID v4."
        }
      }
    },
    "signature": "Crypto"
  },
  "SubtleCrypto": {
    "kind": "interface",
    "name": "SubtleCrypto",
    "documentation": "",
    "members": {
      "decrypt": {
        "kind": "method",
        "name": "decrypt",
        "signature": "decrypt(algorithm: AesCtrParams | AesCbcParams | AesGcmParams | RsaOaepParams, key: CryptoKey, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `decrypt()` method decrypts some encrypted data.",
        "params": [
          {
            "name": "algorithm",
            "type": "AesCtrParams | AesCbcParams | AesGcmParams | RsaOaepParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to use for decryption."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to decrypt (also known as \"ciphertext\")."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": "promise that resolves with the decrypted data (also known as \"plaintext\")."
        }
      },
      "digest": {
        "kind": "method",
        "name": "digest",
        "signature": "digest(algorithm: HashAlgorithmIdentifier | Algorithm<HashAlgorithmIdentifier>, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `digest()` method computes a cryptographic digest of the given data using the given algorithm. A digest is a fixed-length hash of the original data. It is often used to verify the integrity of the original data, or to create a \"fingerprint\" or \"summary\" of the original data that can be used to identify it. Cryptographic digests should exhibit collision-resistance, meaning that it's hard to come up with two different inputs that have the same digest value.",
        "params": [
          {
            "name": "algorithm",
            "type": "HashAlgorithmIdentifier | Algorithm<HashAlgorithmIdentifier>",
            "documentation": "names the algorithm to use."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to be digested"
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": "promise that resolves with the digest value."
        }
      },
      "encrypt": {
        "kind": "method",
        "name": "encrypt",
        "signature": "encrypt(algorithm: AesCtrParams | AesCbcParams | AesGcmParams | RsaOaepParams, key: CryptoKey, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `encrypt()` method encrypts data.",
        "params": [
          {
            "name": "algorithm",
            "type": "AesCtrParams | AesCbcParams | AesGcmParams | RsaOaepParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to use for encryption."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to encrypt (also known as \"plaintext\")."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": "promise that resolves with the encrypted data (also known as \"ciphertext\")."
        }
      },
      "exportKey": {
        "kind": "method",
        "name": "exportKey",
        "signature": "exportKey(format: \"raw\" | \"jwk\" | \"spki\" | \"pkcs8\", key: CryptoKey)",
        "documentation": "The `exportKey()` method exports a key: that is, it takes as input a `CryptoKey` object and gives you the key in an external, portable format. To export a key, the key must have `CryptoKey.extractable` set to `true`.",
        "params": [
          {
            "name": "format",
            "type": "\"raw\" | \"jwk\" | \"spki\" | \"pkcs8\"",
            "documentation": "the format in which to export the key."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to export."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer | JWK>",
          "documentation": "promise that resolves with the exported key."
        }
      },
      "generateKey": {
        "kind": "method",
        "name": "generateKey",
        "signature": "generateKey(algorithm: EcKeyGenParams | RSAHashedKeyGenParams, extractable: boolean, keyUsages: (\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\")[])",
        "documentation": "Use the `generateKey()` method to generate a new key pair for asymmetric algorithms.",
        "params": [
          {
            "name": "algorithm",
            "type": "EcKeyGenParams | RSAHashedKeyGenParams",
            "documentation": "defines the type of key to generate and providing extra algorithm-specific parameters."
          },
          {
            "name": "extractable",
            "type": "boolean",
            "documentation": "indicates whether it will be possible to export the key using `SubtleCrypto.exportKey()` or `SubtleCrypto.wrapKey`."
          },
          {
            "name": "keyUsages",
            "type": "(\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\")[]",
            "documentation": "indicates what can be done with the newly generated key."
          }
        ],
        "returns": {
          "type": "Promise<CryptoKeyPair>",
          "documentation": "promise that resolves with the newly generated `CryptoKeyPair`."
        }
      },
      "importKey": {
        "kind": "method",
        "name": "importKey",
        "signature": "importKey(format: \"raw\" | \"jwk\" | \"spki\" | \"pkcs8\", keyData: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike> | JWK, algorithm: \"AES-CBC\" | \"AES-CTR\" | \"AES-GCM\" | Algorithm<\"AES-CBC\" | \"AES-CTR\" | \"AES-GCM\"> | HmacImportParams | EcKeyImportParams | RsaHashedImportParams, extractable: boolean, keyUsages: (\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\")[])",
        "documentation": "The `importKey()` method imports a key into a `CryptoKey` object. It takes as input a key in an external, portable format and gives you a `CryptoKey` object that can be used in the Web Crypto API.",
        "params": [
          {
            "name": "format",
            "type": "\"raw\" | \"jwk\" | \"spki\" | \"pkcs8\"",
            "documentation": "the format of the key to import."
          },
          {
            "name": "keyData",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike> | JWK",
            "documentation": "the key data to import."
          },
          {
            "name": "algorithm",
            "type": "\"AES-CBC\" | \"AES-CTR\" | \"AES-GCM\" | Algorithm<\"AES-CBC\" | \"AES-CTR\" | \"AES-GCM\"> | HmacImportParams | EcKeyImportParams | RsaHashedImportParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "extractable",
            "type": "boolean",
            "documentation": "indicates whether it will be possible to export the key using `SubtleCrypto.exportKey()` or `SubtleCrypto.wrapKey`."
          },
          {
            "name": "keyUsages",
            "type": "(\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\")[]",
            "documentation": "indicates what can be done with the newly generated key."
          }
        ],
        "returns": {
          "type": "Promise<CryptoKey>",
          "documentation": "promise that resolves with the imported `CryptoKey`."
        }
      },
      "sign": {
        "kind": "method",
        "name": "sign",
        "signature": "sign(algorithm: \"HMAC\" | Algorithm<\"HMAC\"> | EcdsaParams | RsaPssParams, key: CryptoKey, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `sign()` method generates a digital signature. It takes as its argument a key to sign with, some algorithm-identifier specific parameters, and the data to sign.",
        "params": [
          {
            "name": "algorithm",
            "type": "\"HMAC\" | Algorithm<\"HMAC\"> | EcdsaParams | RsaPssParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to use for signing. If `algorithm` identifies a public-key cryptosystem, this is the private key."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to sign."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": "promise that resolves with the signature."
        }
      },
      "verify": {
        "kind": "method",
        "name": "verify",
        "signature": "verify(algorithm: \"HMAC\" | Algorithm<\"HMAC\"> | EcdsaParams | RsaPssParams, key: CryptoKey, signature: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>, data: ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>)",
        "documentation": "The `verify()` method verifies a digital signature.",
        "params": [
          {
            "name": "algorithm",
            "type": "\"HMAC\" | Algorithm<\"HMAC\"> | EcdsaParams | RsaPssParams",
            "documentation": "defines the algorithm to use and any extra-parameters."
          },
          {
            "name": "key",
            "type": "CryptoKey",
            "documentation": "the key to use for verifying. It is the secret key for a symmetric algorithm and the public key for a public-key system."
          },
          {
            "name": "signature",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the signature to verify."
          },
          {
            "name": "data",
            "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>",
            "documentation": "the data to verify."
          }
        ],
        "returns": {
          "type": "Promise<boolean>",
          "documentation": "promise that resolves with a boolean indicating whether the signature is valid."
        }
      },
      "deriveBits": {
        "kind": "method",
        "name": "deriveBits",
        "signature": "deriveBits(algorithm: EcdhKeyDeriveParams, baseKey: CryptoKey, length: number)",
        "documentation": "The `deriveBits()` method derives an array of bits from a base key.",
        "params": [
          {
            "name": "algorithm",
            "type": "EcdhKeyDeriveParams",
            "documentation": "defines the derivation algorithm to use."
          },
          {
            "name": "baseKey",
            "type": "CryptoKey",
            "documentation": "A `CryptoKey` representing the input to the derivation algorithm. Currently, only an ECDH private key is possible."
          },
          {
            "name": "length",
            "type": "number",
            "documentation": "A number representing the number of bits to derive. Currently, the number should be a multiple of 8."
          }
        ],
        "returns": {
          "type": "Promise<ArrayBuffer>",
          "documentation": ""
        }
      }
    },
    "signature": "SubtleCrypto"
  },
  "CryptoKey": {
    "kind": "interface",
    "name": "CryptoKey",
    "documentation": "",
    "members": {
      "type": {
        "kind": "property",
        "name": "type",
        "signature": "readonly type: \"secret\" | \"private\" | \"public\";",
        "documentation": "The type of key the object represents.",
        "type": "\"secret\" | \"private\" | \"public\""
      },
      "extractable": {
        "kind": "property",
        "name": "extractable",
        "signature": "readonly extractable: boolean;",
        "documentation": "A boolean value indicating whether or not the key may be extracted using `SubtleCrypto.exportKey()` or `SubtleCrypto.wrapKey()`.",
        "type": "boolean"
      },
      "algorithm": {
        "kind": "property",
        "name": "algorithm",
        "signature": "readonly algorithm: object;",
        "documentation": "An object describing the algorithm for which this key can be used and any associated extra parameters.",
        "type": "object"
      },
      "usages": {
        "kind": "property",
        "name": "usages",
        "signature": "readonly usages: Array<\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\">;",
        "documentation": "An array of strings, indicating what can be done with the key.",
        "type": "(\"encrypt\" | \"decrypt\" | \"sign\" | \"verify\" | \"deriveKey\" | \"deriveBits\")[]"
      }
    },
    "signature": "CryptoKey"
  },
  "CryptoKeyPair": {
    "kind": "interface",
    "name": "CryptoKeyPair",
    "documentation": "The `CryptoKeyPair` dictionary represents a key pair for an asymmetric cryptography algorithm, also known as a public-key algorithm.",
    "members": {
      "privateKey": {
        "kind": "property",
        "name": "privateKey",
        "signature": "readonly privateKey: CryptoKey;",
        "documentation": "A `CryptoKey` object representing the private key. For encryption and decryption algorithms, this key is used to decrypt. For signing and verification algorithms it is used to sign.",
        "type": "CryptoKey"
      },
      "publicKey": {
        "kind": "property",
        "name": "publicKey",
        "signature": "readonly publicKey: CryptoKey;",
        "documentation": "A CryptoKey object representing the public key. For encryption and decryption algorithms, this key is used to encrypt. For signing and verification algorithms it is used to verify signatures.",
        "type": "CryptoKey"
      }
    },
    "signature": "CryptoKeyPair"
  },
  "Algorithm": {
    "kind": "interface",
    "name": "Algorithm",
    "documentation": "The `Algorithm` dictionary of the Web Crypto API represents the object that should be passed as the `algorithm` parameter of most `SubtleCrypto` methods.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: I;",
        "documentation": "The name of the algorithm to use.",
        "type": "I"
      }
    },
    "signature": "Algorithm"
  },
  "AlgorithmIdentifier": {
    "kind": "declaration",
    "name": "AlgorithmIdentifier",
    "signature": "type AlgorithmIdentifier = string;",
    "documentation": "The `AlgorithmIdentifier` type of the Web Crypto API represents the name of an algorithm."
  },
  "HashAlgorithmIdentifier": {
    "kind": "declaration",
    "name": "HashAlgorithmIdentifier",
    "signature": "type HashAlgorithmIdentifier = \"SHA-1\" | \"SHA-256\" | \"SHA-384\" | \"SHA-512\";",
    "documentation": "The `HashAlgorithmIdentifier` type of the Web Crypto API represents the name of a hash algorithm."
  },
  "AesKeyGenParams": {
    "kind": "interface",
    "name": "AesKeyGenParams",
    "documentation": "The `AesKeyGenParams` dictionary of the Web Crypto API represents the object that should be passed as the `algorithm` parameter of the `SubtleCrypto.generateKey()` method when generating a new AES key.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"AES-GCM\" | \"AES-CBC\" | \"AES-CTR\" | \"AES-CFB\" | \"AES-KW\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"AES-CBC\" | \"AES-CTR\" | \"AES-GCM\" | \"AES-CFB\" | \"AES-KW\""
      },
      "length": {
        "kind": "property",
        "name": "length",
        "signature": "length: 128 | 192 | 256;",
        "documentation": "The length of the key, in bits.",
        "type": "128 | 192 | 256"
      }
    },
    "signature": "AesKeyGenParams"
  },
  "AesCtrParams": {
    "kind": "interface",
    "name": "AesCtrParams",
    "documentation": "The `AesCtrParams` dictionary of the Web Crypto API represents the object that should be passed as the `algorithm` parameter of the `SubtleCrypto.encrypt()` and `SubtleCrypto.decrypt()`, `SubtleCrypto.wrapKey()` and `SubtleCrypto.unwrapKey()` methods when using the AES-CTR algorithm.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"AES-CTR\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"AES-CTR\""
      },
      "counter": {
        "kind": "property",
        "name": "counter",
        "signature": "counter: ArrayBuffer | ArrayBufferView | DataView;",
        "documentation": "The initial value of the counter block. This must be 16-byte long (the AES block size). The rightmost `length` bits of this block are used for the counter, and the rest is used for the nonce.",
        "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>"
      },
      "length": {
        "kind": "property",
        "name": "length",
        "signature": "length: number;",
        "documentation": "The number of bits in the counter block that are used for the actual counter. The counter must be big enough that it doesn't wrap. If the message is `n` blocks and the counter is `m` bits long, then the following must be true: `n < 2^m`.",
        "type": "number"
      }
    },
    "signature": "AesCtrParams"
  },
  "AesCbcParams": {
    "kind": "interface",
    "name": "AesCbcParams",
    "documentation": "The `AesCbcParams` dictionary of the Web Crypto API represents the object that should be passed as the `algorithm` parameter of the `SubtleCrypto.encrypt()` and `SubtleCrypto.decrypt()`, `SubtleCrypto.wrapKey()` and `SubtleCrypto.unwrapKey()` methods when using the AES-CBC algorithm.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"AES-CBC\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"AES-CBC\""
      },
      "iv": {
        "kind": "property",
        "name": "iv",
        "signature": "iv: ArrayBuffer | ArrayBufferView | DataView;",
        "documentation": "The initialization vector to use for the operation. This must be 16-byte long (the AES block size), unpredictable, and preferably cryptographically random. However, it is not required to be secret (it may be transmitted unencrypted along with the ciphertext).",
        "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>"
      }
    },
    "signature": "AesCbcParams"
  },
  "AesGcmParams": {
    "kind": "interface",
    "name": "AesGcmParams",
    "documentation": "The `AesGcmParams` dictionary of the Web Crypto API represents the object that should be passed as the `algorithm` parameter of the `SubtleCrypto.encrypt()` and `SubtleCrypto.decrypt()`, `SubtleCrypto.wrapKey()` and `SubtleCrypto.unwrapKey()` methods when using the AES-GCM algorithm.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"AES-GCM\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"AES-GCM\""
      },
      "iv": {
        "kind": "property",
        "name": "iv",
        "signature": "iv: ArrayBuffer | ArrayBufferView | DataView;",
        "documentation": "The initialization vector to use for the operation. This must be 12-byte long (the GCM block size), unpredictable, and preferably cryptographically random. This must be unique for every encryption operation carried out with a given key. Put another way, never reuse an IV with the same key.",
        "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>"
      },
      "additionalData": {
        "kind": "property",
        "name": "additionalData",
        "signature": "additionalData?: ArrayBuffer | ArrayBufferView | DataView;",
        "documentation": "Contains additional data that will not be encrypted but will be authenticated. This is optional, and can be omitted if you don't need to pass any additional data. If `additionalData` is specified, then the same data must be given in the corresponding call to `decrypt()`. If the data is not the same, then the decryption will fail. This gives you a way to authenticate the data, without having to encrypt it.",
        "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>"
      },
      "tagLength": {
        "kind": "property",
        "name": "tagLength",
        "signature": "tagLength?: number;",
        "documentation": "The length of the authentication tag, in bits. This must be of size 96.",
        "type": "number"
      }
    },
    "signature": "AesGcmParams"
  },
  "RsaOaepParams": {
    "kind": "interface",
    "name": "RsaOaepParams",
    "documentation": "The `RsaOaepParams` dictionary of the Web Crypto API represents the object that should be passed as the `algorithm` parameter of the `SubtleCrypto.encrypt()` and `SubtleCrypto.decrypt()` methods when using the RSA-OAEP algorithm.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"RSA-OAEP\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"RSA-OAEP\""
      },
      "label": {
        "kind": "property",
        "name": "label",
        "signature": "label?: ArrayBuffer | ArrayBufferView | DataView;",
        "documentation": "The label to use. If not provided, it will default to an empty ArrayBuffer.",
        "type": "ArrayBuffer | ArrayBufferView<ArrayBufferLike> | DataView<ArrayBufferLike>"
      }
    },
    "signature": "RsaOaepParams"
  },
  "HmacKeyGenParams": {
    "kind": "interface",
    "name": "HmacKeyGenParams",
    "documentation": "The `HmacKeyGenParams` dictionary of the Web Crypto API represents the object that should be passed as the `algorithm` parameter of the `SubtleCrypto.generateKey()` method when generating a new HMAC key.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"HMAC\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"HMAC\""
      },
      "hash": {
        "kind": "property",
        "name": "hash",
        "signature": "hash: \"SHA-1\" | \"SHA-256\" | \"SHA-384\" | \"SHA-512\";",
        "documentation": "A string representing the name of the digest function to use.",
        "type": "\"SHA-1\" | \"SHA-256\" | \"SHA-384\" | \"SHA-512\""
      },
      "length": {
        "kind": "property",
        "name": "length",
        "signature": "length?: number;",
        "documentation": "The length of the key, in bits. If the length is not specified, then the generated key will be as long as the block size of the hash function you have chosen. Unless you have a good reason to use a different length, omit this property and use the default.",
        "type": "number"
      }
    },
    "signature": "HmacKeyGenParams"
  },
  "EcKeyGenParams": {
    "kind": "interface",
    "name": "EcKeyGenParams",
    "documentation": "The EcKeyGenParams dictionary of the Web Crypto API represents the object that should be passed as the algorithm parameter into `SubtleCrypto.generateKey()`, when generating any elliptic-curve-based key pair: that is, when the algorithm is identified as either of ECDSA or ECDH.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"ECDSA\" | \"ECDH\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"ECDSA\" | \"ECDH\""
      },
      "namedCurve": {
        "kind": "property",
        "name": "namedCurve",
        "signature": "namedCurve: \"P-256\" | \"P-384\" | \"P-521\";",
        "documentation": "The name of the elliptic curve to use. This may be any of the following names for NIST-approved curves.",
        "type": "\"P-256\" | \"P-384\" | \"P-521\""
      }
    },
    "signature": "EcKeyGenParams"
  },
  "RSAHashedKeyGenParams": {
    "kind": "interface",
    "name": "RSAHashedKeyGenParams",
    "documentation": "The RSAHashedKeyGenParams dictionary of the Web Crypto API represents the object that should be passed as the algorithm parameter into `SubtleCrypto.generateKey()`, when the algorithm is identified as either of RSASSA-PKCS1-v1_5, RSA-PSS or RSA-OAEP.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"RSASSA-PKCS1-v1_5\" | \"RSA-PSS\" | \"RSA-OAEP\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"RSA-OAEP\" | \"RSASSA-PKCS1-v1_5\" | \"RSA-PSS\""
      },
      "modulusLength": {
        "kind": "property",
        "name": "modulusLength",
        "signature": "modulusLength: number;",
        "documentation": "The modulus length, in bits.",
        "type": "number"
      },
      "publicExponent": {
        "kind": "property",
        "name": "publicExponent",
        "signature": "publicExponent: Uint8Array;",
        "documentation": "The public exponent.",
        "type": "Uint8Array<ArrayBufferLike>"
      },
      "hash": {
        "kind": "property",
        "name": "hash",
        "signature": "hash: HashAlgorithmIdentifier;",
        "documentation": "The hash algorithm to use.",
        "type": "HashAlgorithmIdentifier"
      }
    },
    "signature": "RSAHashedKeyGenParams"
  },
  "HmacImportParams": {
    "kind": "interface",
    "name": "HmacImportParams",
    "documentation": "The `HmacImportParams` dictionary of the Web Crypto API represents the object that should be passed as the `algorithm` parameter of the `SubtleCrypto.importKey()` method when importing an HMAC key.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"HMAC\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"HMAC\""
      },
      "hash": {
        "kind": "property",
        "name": "hash",
        "signature": "hash: HashAlgorithmIdentifier;",
        "documentation": "The name of the digest function to use.",
        "type": "HashAlgorithmIdentifier"
      },
      "length": {
        "kind": "property",
        "name": "length",
        "signature": "length?: number;",
        "documentation": "The length of the key, in bits. If the length is not specified, then the generated key will be as long as the block size of the hash function you have chosen. Unless you have a good reason to use a different length, omit this property and use the default.",
        "type": "number"
      }
    },
    "signature": "HmacImportParams"
  },
  "EcKeyImportParams": {
    "kind": "interface",
    "name": "EcKeyImportParams",
    "documentation": "The `EcKeyImportParams` dictionary of the Web Crypto API represents the object that should be passed as the algorithm parameter into SubtleCrypto.importKey() or SubtleCrypto.unwrapKey(), when generating any elliptic-curve-based key pair: that is, when the algorithm is identified as either of ECDSA or ECDH.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"ECDSA\" | \"ECDH\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"ECDSA\" | \"ECDH\""
      },
      "namedCurve": {
        "kind": "property",
        "name": "namedCurve",
        "signature": "namedCurve: \"P-256\" | \"P-384\" | \"P-521\";",
        "documentation": "The name of the elliptic curve to use. This may be any of the following names for NIST-approved curves.",
        "type": "\"P-256\" | \"P-384\" | \"P-521\""
      }
    },
    "signature": "EcKeyImportParams"
  },
  "RsaHashedImportParams": {
    "kind": "interface",
    "name": "RsaHashedImportParams",
    "documentation": "The `RsaHashedImportParams` dictionary of the Web Crypto API represents the object that should be passed as the algorithm parameter into SubtleCrypto.importKey(), when the algorithm is identified as either of RSASSA-PKCS1-v1_5, RSA-PSS or RSA-OAEP.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"RSASSA-PKCS1-v1_5\" | \"RSA-PSS\" | \"RSA-OAEP\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"RSA-OAEP\" | \"RSASSA-PKCS1-v1_5\" | \"RSA-PSS\""
      },
      "hash": {
        "kind": "property",
        "name": "hash",
        "signature": "hash: HashAlgorithmIdentifier;",
        "documentation": "The hash algorithm to use.",
        "type": "HashAlgorithmIdentifier"
      }
    },
    "signature": "RsaHashedImportParams"
  },
  "EcdsaParams": {
    "kind": "interface",
    "name": "EcdsaParams",
    "documentation": "The `EcdsaParams` dictionary of the Web Crypto API represents the object that should be passed as the algorithm parameter into SubtleCrypto.sign() or SubtleCrypto.verify() when using the ECDSA algorithm.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"ECDSA\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"ECDSA\""
      },
      "hash": {
        "kind": "property",
        "name": "hash",
        "signature": "hash: \"SHA-1\" | \"SHA-256\" | \"SHA-384\" | \"SHA-512\";",
        "documentation": "An identifier for the digest algorithm to use.",
        "type": "\"SHA-1\" | \"SHA-256\" | \"SHA-384\" | \"SHA-512\""
      }
    },
    "signature": "EcdsaParams"
  },
  "RsaPssParams": {
    "kind": "interface",
    "name": "RsaPssParams",
    "documentation": "The `RsaPssParams` dictionary of the Web Crypto API represents the object that should be passed as the algorithm parameter into SubtleCrypto.sign() or SubtleCrypto.verify() when using the RSA-PSS algorithm.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"RSA-PSS\";",
        "documentation": "The name of the algorithm to use.",
        "type": "\"RSA-PSS\""
      },
      "saltLength": {
        "kind": "property",
        "name": "saltLength",
        "signature": "saltLength: number;",
        "documentation": "The length of the salt to use.",
        "type": "number"
      }
    },
    "signature": "RsaPssParams"
  },
  "EcdhKeyDeriveParams": {
    "kind": "interface",
    "name": "EcdhKeyDeriveParams",
    "documentation": "The `EcdhKeyDeriveParams` dictionary of the Web Crypto API represents the object that should be passed as the algorithm parameter into `SubtleCrypto.deriveKey()`, when using the ECDH algorithm.",
    "members": {
      "name": {
        "kind": "property",
        "name": "name",
        "signature": "name: \"ECDH\";",
        "documentation": "The name of the algorithm to use. Only the \"ECDH\" value is possible.",
        "type": "\"ECDH\""
      },
      "public": {
        "kind": "property",
        "name": "public",
        "signature": "public: CryptoKey;",
        "documentation": "A `CryptoKey` object representing the public key of the other entity.",
        "type": "CryptoKey"
      }
    },
    "signature": "EcdhKeyDeriveParams"
  },
  "TypedArray": {
    "kind": "declaration",
    "name": "TypedArray",
    "signature": "type TypedArray = | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array;",
    "documentation": "The TypedArray interface represents an array-like view of an underlying binary data buffer. It is used to represent a generic, fixed-length raw binary data buffer. The ArrayBuffer that underlies a typed array can be accessed and modified by using the ArrayBufferView methods. Note that this type does not include Float32Array and Float64Array, which makes it differ from the ArrayBufferView type."
  },
  "JWKValue": {
    "kind": "declaration",
    "name": "JWKValue",
    "signature": "type JWKValue = null | boolean | number | string | string[] | JWK;",
    "documentation": "JSON Web Key Value. JWKs are not supported for now, since webcrypto doesn't support exporting key/pairs"
  },
  "JWK": {
    "kind": "interface",
    "name": "JWK",
    "documentation": "Object representable with JSON Web Key.",
    "members": {},
    "signature": "JWK"
  }
}